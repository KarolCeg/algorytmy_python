from collections import defaultdict, deque

def minimalny(a, b):
    if a < b:
        return a
    return b

def ford_fulkerson(graph, z, d):
    przeplyw_dict = defaultdict(int)
    max_przeplyw = 0

    while True:
        odw = defaultdict(bool)
        odw[z] = True

        queue = deque([z])

        poprzednik = {}
        for ob_w in graph:
            poprzednik[ob_w] = None

        while queue and queue[-1] != d:
            ob_w = queue.popleft()
            for s in graph[ob_w]:
                if not odw[s] and graph[ob_w][s] - przeplyw_dict[(ob_w, s)] > 0:
                    odw[s] = True
                    queue.append(s)
                    poprzednik[s] = ob_w

        if poprzednik[d] is not None:
            obc_przeplyw = float('inf')
            ob_w = d
            while ob_w != z:
                m = graph[poprzednik[ob_w]][ob_w] - przeplyw_dict[(poprzednik[ob_w], ob_w)]
                obc_przeplyw = minimalny(obc_przeplyw, m)
                ob_w = poprzednik[ob_w]
            ob_w = d
            while ob_w != z:
                przeplyw_dict[(poprzednik[ob_w], ob_w)] += obc_przeplyw
                przeplyw_dict[(ob_w, poprzednik[ob_w])] -= obc_przeplyw
                ob_w = poprzednik[ob_w]

            max_przeplyw += obc_przeplyw
        else:
            break

    return max_przeplyw

if __name__ == "__main__":
    g_wierzcholki = ['S', 'V1', 'V2', 'V3', 'V4', 't']
    g_krawedzie = [('S', 'V1', 16), ('S', 'V2', 13), ('V1', 'V2', 10), ('V2', 'V1', 4), ('V1', 'V3', 12), ('V3', 'V2', 9), ('V2', 'V4', 14), ('V4', 'V3', 7), ('V3', 't', 20), ('V4', 't', 4)]

    # Create graph adjacency list with capacities
    graph = defaultdict(dict)
    for u, v, capacity in g_krawedzie:
        graph[u][v] = capacity
        if v not in graph:  # ensure reverse path exists even if initially no capacity
            graph[v] = {}

    z = 'S'  # source
    d = 't'  # sink
    max_flow = ford_fulkerson(graph, z, d)
    print(f'Maximum flow: {max_flow}')
